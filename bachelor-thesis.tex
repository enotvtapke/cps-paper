\documentclass[times]{itmo-student-thesis}

%% Опции пакета:
%% - specification - если есть, генерируется задание, иначе не генерируется
%% - annotation - если есть, генерируется аннотация, иначе не генерируется
%% - times - делает все шрифтом Times New Roman, собирается с помощью xelatex
%% - languages={...} - устанавливает перечень используемых языков. По умолчанию это {english,russian}.
%%                     Последний из языков определяет текст основного документа.

%% Делает запятую в формулах более интеллектуальной, например:
%% $1,5x$ будет читаться как полтора икса, а не один запятая пять иксов.
%% Однако если написать $1, 5x$, то все будет как прежде.
\usepackage{icomma}

%% Один из пакетов, позволяющий делать таблицы на всю ширину текста.
\usepackage{tabularx}

\lstloadlanguages{Haskell}

%% Делает кавычки в листингах прямыми.
\usepackage{fontspec}
\lstset{basicstyle=\addfontfeature{Mapping=no-mapping-ligtex}}

%% Указываем файл с библиографией.
\addbibresource{bachelor-thesis.bib}

\begin{document}
\studygroup{M34351}
\title{Разработка библиотеки комбинаторных парсеров высшего порядка нечувствительных к левой рекурсии}
\author{Ступников Александр Сергеевич}{Ступников А.С.}
\supervisor{Забашта Алексей Сергеевич}{Забашта А.С.}{доцент., к.т.н.}{главный научный сотрудник Университета ИТМО}
\publishyear{2024}
% %% Дата выдачи задания. Можно не указывать, тогда надо будет заполнить от руки.
% \startdate{01}{сентября}{2024}
% %% Срок сдачи студентом работы. Можно не указывать, тогда надо будет заполнить от руки.
% \finishdate{31}{мая}{2024}
% %% Дата защиты. Можно не указывать, тогда надо будет заполнить от руки.
% \defencedate{15}{июня}{2024}

\addconsultant{Булычев Д.Ю.}{канд. физ.-мат. наук, доцент}

\secretary{Штумпф С.А.}

%% Задание TODO
%% Аннотация TODO

%% Эта команда генерирует титульный лист и аннотацию.
\maketitle{Бакалавр}

%% Список определений
\startdefinitionspage

\begin{enumerate}
    \item \makedefinition[язык]{Формальный язык}{множество конечных слов (строк, цепочек) над конечным алфавитом}

    \item \textbf{Формальная грамматика}~(англ. \textit{formal grammar})~--- способ описания формального языка, 
        представляющий собой четверку
    
        $\Gamma =\langle \Sigma, N, S \in N, P \subset ((\Sigma \cup N)^* N (\Sigma \cup N)^*) \times (\Sigma\cup N)^{*}\rangle$, где:
        \begin{itemize}
            \item \makedefinition{$\Sigma$}{алфавит, элементы которого называют \textbf{терминалами} (англ. \textit{terminals})}
            \item \makedefinition{$N$}{множество, элементы которого называют \textbf{нетерминалами} (англ. \textit{nonterminals})}
            \item \makedefinition{$S$}{начальный символ грамматики (англ. \textit{start symbol})}
            \item \makedefinition{$P$}{набор правил вывода (англ. \textit{production rules} или \textit{productions}) $\alpha\rightarrow \beta$}
        \end{itemize}

    \item \makedefinition[КСГ, англ. \textit{сontext-free grammar}]{Контекстно-свободная грамматика}{грамматика, у которой в 
        левых частях всех правил стоят только одиночные нетерминалы}

    \item \makedefinition[англ. \textit{context-free language}]{Контекстно-свободный язык}{язык, задаваемый контекстно-свободной грамматикой}

    \item \makedefinition[разбор, парсинг, англ. \textit{parsing}]{Синтаксический анализ}{процесс сопоставления линейной последовательности 
        лексем (слов, токенов) формального языка с его формальной грамматикой}

    \item \makedefinition[парсер, англ. \textit{parser}]{Синтаксический анализатор}{программа, производящая ситанксический анализ}

    \item \makedefinition{Семантика языка}{это смысловое значение конструкций языка. (функция, сопоставляющую строку, 
        принадлежащую языку, некоторому значению)}
        
    \item \makedefinition[ввод]{Входной поток}{линейная последовательность токенов, которая передаётся парсеру для разбора}
    
    \item \makedefinition{LL(k) грамматика}{грамматика, при разборе которой на основании $k$ токенов входного потока 
        можно однозначно определить правило вывода, которое необходимо применить}

    \item \makedefinition[англ. \textit{backtracking}]{Поиск с возвратом}{техника, при которой парсер возвращает поток ввода в 
        исходное состояние после попытки разбора каждого правила при разборе нетерминала}

    \item \makedefinition{Longest мatch first}{принцип проектирования парсера, при котором правило, 
        при разборе которой способно поглотиться наибольшее число символов входного потока, должно быть опробовано первым при разборе нетерминала языка}

    \item \makedefinition{Lookahead}{число символов входного потока, которое парсер учитывает при выборе правила в 
        рамках разбора нетерминала}

    \item \makedefinition[англ. \textit{domain-specific language}, \textit{DSL}]{Предметно-ориентированный язык}{формальный язык, специализированный для конкретной 
        области применения}
\end{enumerate}

%% Оглавление
\tableofcontents

%% Макрос для введения. Совместим со старым стилевиком.
\startprefacepage
\textbf{Актуальность работы}

Задачи синтаксического анализа повсеместно встречаются в информатике. Традиционно синтаксический анализ производится с
использованием генераторов парсеров, однако такой подход обладает рядом недостатков. В частности, он предполгает
использование чужеродной для программы синтаксического анализа структуры, не имеющей глубокой интеграции в язык, на
котором эта программа написана.

Однако для синтаксического анализа используется и другой подход, лишённый этого недостатка генераторов парсеров:
комбинаторные парсеры. С их помощью можно лаконичным и естественным образом выразить синтаксис и семантику языка, кроме
того они полностью интегрированы в язык, использующейся для написания программы синтаксического анализа.

Тем не менее существующие реализации комбинаторных парсеров  не обладают свойством композиционности. То есть нельзя в
общем случае подставлять друг в друга грамматики, закодированные с использованием комбинаторов парсеров. В частности,
невозможно распознавать леворекурсивные грамматики, которые могут возникать в результате использования парсеров высшего
порядка из нелеворекурсивных грамматик.  Такое положение вещей не позволяет раскрыть полный потенциал комбинаторных
парсеров, затрудняя использование парсеров высшего порядка, а также заставляя кодировать леворекурсивные грамматики в
неестественном виде.

\textbf{Цель работы}

Создание интрумента синтаксического анализа, позволяющего композировать грамматики произвольным образом. 

\textbf{Задача работы}

Создание библиотеки комбинаторных парсеров, обладающих следующими свойствами:

\begin{enumerate}
    \item Распознавание любой однозначной контекстно свободной грамматики.
    \item Нечувствительность к longest match first.
    \item Нечувствительность к левой рекурсии.
    \item Полиномиальное время работы.
\end{enumerate}

\textbf{Структура работы}

\begin{enumerate}
    \item В Главе 1 представлено описание предметной области.
    \item В Главе 2 представлен обзор существующих подходов, описание выбранного подхода, детали реализации решения,
    верификация результатов.
\end{enumerate}

%% Начало содержательной части.
\chapter{Обзор предметной области}

\section{Подходы к синтаксическому анализу}\label{sec:parsing_approaches}

Для выполнения синтаксического анализа используют парсеры. По сути парсер это функция из некоторого состояния в
множества пар из изменённого состояния и результата, то есть функция $S \rightarrow (S \times R)^*$, где $S$
--- множество состояний, $R$ --- множество результатов. На практике состоянием обычно является поток
некоторых символов или токенов, а результатом --- дерево разбора. Есть несколько подходов к написанию парсеров. Самый
наивный --- ручное написание парсера, например, с помощью нисходящего рекурсивного спуска. Такой подход позволяет
строить производительные и тонко настраиваемые парсеры, однако, как правило, не подходит для разбора произвольных КСГ,
а также значительно увеличивает время и сложность разработки программы синтаксического анализа. Одним из более
продвинутых подходов является использование генераторов парсеров (таких как Bison\cite{bison} или
ANTLR\cite{antlr}), которые создают парсер на основе описания грамматики путём использования некоторого
предметно-ориентированного языка. Другим продвинутым подходом является использование комбинаторных парсеров, которые
представляют из себя функции, путём композиции которых пользователь неявно задаёт грамматику и семантику языка, анализ
которого будет производиться.

\section{Преимущества комбинаторных парсеров}\label{sec:parser_combinators_advantages}

Традиционно для крупных языков программирования используют генераторы парсеров, так как они за счёт выполнения
статического анализа грамматики имеют меньшее время работы. Такое время работы также достигается за счёт того, что
генераторы парсеров работают как правило только с $LL(k)$ грамматиками. Следует заметить, что такие
грамматики однозначны.

Напротив, комбинаторные парсеры зачастую способны работать с любыми контекстно-свободными грамматиками, однако при этом
имеют полиномиальное или даже экспоненциальное относительно длины ввода время работы на некоторых грамматиках и входных
данных.

Крайне важной чертой, отличающей  комбинаторные парсеры от генераторов парсеров, является интегрированность первых в
язык программирования, на котором написан парсер. Это означает, что комбинаторные парсеры, являясь обычными функциями,
написаны на языке компилятора. Это позволяет получить такие преимущества, как, например, проверка типов на этапе
компиляции парсера. Кроме того такая интегрированность позволяет писать комбинаторные парсеры более абстрактно, отходя
от деталей грамматики и семантики конкретного языка программирования. Грамматики, описанные в терминах комбинаторных
парсеров, можно простым образом композировать, а части описания этих грамматик переиспользовать в нескольких парсерах.

\section{Cуществующие практические реализации комбинаторных парсеров и их проблемы}\label{sec:current_parser_combinators_problems}

Простейшая реализация комбинаторного парсера использует backtracking, чтобы иметь неограниченный lookahead и, как
следствие, возможность разбирать произвольные КСГ. Однако использование backtracking может приводить к
экспоненциальному времени разбора некоторых слов для ряда грамматик. Например, рассмотрим грамматику на
рис.~\ref{exp_grammar}.

\begin{figure}[!h]
\caption{Грамматика c экспоненциальной сложностью}\label{exp_grammar}
\[
    \begin{array}{lll}
        A & \to & xAa      \\
          &     & xAb      \\
          &     & \epsilon
    \end{array}
\]
\end{figure}

На вводах типа \lstinline[language=Haskell]{"xxxxbbbb"} (которые можно записать регулярным выражением $x\{n\}b\{n\}$) cложность разбора
в соответствии с грамматикой на рис.~\ref{exp_grammar} растёт экспоненциально с ростом $n$.
Действительно, при раскрытии нетерминала $A$ парсер с backtracking сначала пытается применить первое
правило, то есть $A \to xAa$. При этом на вводах типа $x\{n\}b\{n\}$ при раскрытии
$A$ всегда необходимо применять второе правило. Получается, что парсер как бы перебирает в
лексикографическом порядке все строки вида $x\{n\}(a|b)\{n\}$ для некоторого $n$, притом строка
$x\{n\}b\{n\}$ будет проверена последней, а значит, парсер сделает число шагов равное числу строк вида
$x\{n\}(a|b)\{n\}$ минус 1, то есть для заданного $n$ парсер сделает $2^{n-1}$ шагов.

Во избежание экспоненциального времени работы некоторые практические реализации комбинаторных парсеров могут делать
backtracking, только если пользователь явно укажет, что он необходим при разборе правила некоторого нетерминала (так
делает megaprsec\cite{megaparsec} с помощью кобинатора try). Это позволяет достигнуть линейного времени работы,
однако использование этого подхода приводит к тому, что парсеры приходится писать с учётом longest match first, что не
позволяет разбирать неоднозначные грамматики, а также приводит к невозможности описать любую КСГ. Это плохо само по
себе, однако ещё хуже то, что следствием этого является невозможность композировать такие парсеры, ведь при
произвольном объединении грамматик путём композирования функций-парсеров longest match first может перестать
соблюдаться. Например, при объединении грамматик, состоящих из нетерминалов $A$ и
$B$ с рис.~\ref{uncomposable_grammar}, путём задания парсера для нетерминала $C$ строку
\lstinline|"somebody"| нельзя будет полностью распознать, потому что её префикс \lstinline|"some"| будет поглощён правилом
$A \to some$, хотя грамматика из нетерминала $B$ способна поглотить весь поток ввода.

\begin{figure}[!h]
    \caption{Неправильное объединение грамматик}\label{uncomposable_grammar}
    \[
        \begin{array}{lll}
            A & \to & anybody \\
              &     & some  \\
            B & \to & somebody \\
              &     & any  \\
            C & \to & A  \\
              &     & B
        \end{array}
    \]
\end{figure}

Другим подходом, позволяющим комбинаторным парсерам с backtracking работать за время меньшее, чем экспоненциальное,
является использование мемоизации. Причина экспоненциального времени работы парсеров с backtracking (как в том числе
можно видеть из примера c рис. \ref{exp_grammar}) заключается в том, что одна и та же часть ввода разбирается
парсером несколько раз. Такого поведения можно избежать путём запоминания промежуточных результатов разбора парсера.
При использовании комбинаторного парсера любой нетерминал грамматики является функцией, которая принимает поток ввода и
возвращает список пар из изменённого состояния и результата. Например, парсер для нетерминала $A \to aA | eps$ на
строке \lstinline{"aaa"} вернёт \lstinline{[("aaa", "")("aa", "a"), ("a", "aa"), ("", "aaa")]}. Для мемоизации парсера
$A$ необходимо завести таблицу, в которую при первом вызове парсера $A$ на
\lstinline{"aaa"} добавится запись о том, что для ввода \lstinline{"aaa"} парсер должен вернуть
\lstinline{[("aaa", "")("aa", "a"), ("a", "aa"), ("", "aaa")]}. При последующих вызовах парсера $A$ на \lstinline{"aaa"}
будет возвращаться мемоизированный результат. При условии возможности находить хэш частей входного потока и сравнивать
их за константное время, эта операция выполняется за константное время. Следует заметить, что подход с мемоизацией
обладает теми же свойствами, что и хорошо известный алгоритм Эрли\cite{norvig_techniques_1991}. Мемоизированные парсеры с
backtracking способны разбрирать любую КСГ за полиномиальное время.

Тем не менее большинство мемоизированных комбинаторных парсеров с backtracking ограничены в том, как их можно
комбинировать между собой. Особенно это касается комбинаторных парсеров высшего порядка, которые на основе одних
парсеров создают другие. Одной из проблем является невозможность большинства комбинаторных парсеров завершаться при
разборе леворекурсивных грамматик.

\section{Левая рекурсия}\label{sec:left_recursion}

Левая рекурсия возникает, когда для разбора нетерминала грамматики необходимо разобрать этот же нетерминала. 

\begin{figure}[!h]
    \caption{Леворекурсивная грамматика}\label{leftrec_grammar}
    \[
        \begin{array}{lll}
            E & \to & E+E \\
              &     & t
        \end{array}
    \]
\end{figure}

Грамматику и семантику некоторых языков гораздо удобнее описывать с использованием левой рекурсии. Кроме того
левая рекурсия может возникнуть при использовании комбинаторных парсеров высшего порядка. Рассмотрим пример из листинга 
\ref{lst:higher_order_left_rec}.

\begin{lstlisting}[float=!h,caption={Возникновение левой рекурсии},label={lst:higher_order_left_rec}]
    seq (x, y) = x ";" y
    stmt = seq (stmt, stmt) | VAR ":=" EXPR
\end{lstlisting}

Сам по себе парсер \lstinline{seq} нелеворекурсивен, однако при вызове его с \lstinline{stmt} в качестве первого аргумента возникает левая рекурсия.
Этот нарочито простой пример показывает, как левая рекурсия может неожиданным образом возникнуть при использовании
парсеров высшего порядка.

Таким образом одно из главных преимуществ комбинаторных парсеров, заключающееся в их композиционности, остаётся
раскрытым не до конца в случае, когда леворекурсивные грамматики не могут быть разобраны парсером.

\section{Типы комбинаторных парсеров}\label{sec:parser_combinators_types}

Для написания комбинаторных парсеров обычно используют одну из двух абстракций: \textbf{монаду}~(англ. \textit{monad}) 
или \textbf{аппликатив}~(англ. \textit{applicative}). Парсеры, которые используют эти абстракции называют соответственно 
\textbf{монадическими} и \textbf{апликативными}. TODO дописать, сделать ссылки.

\chapterconclusion

TODO

\chapter{ПРЕДЛАГАЕМЫЙ ПОДХОД}

В этой главе сначала даётся обзор существующих решений, которые потенциально могут решать задачу, поставленную в рамках 
работы, рассматриваются недостатки существующих решений. Далее предлагается собственное решение, разбираются детали его
практической реализации.   

\section{Существующие решения}\label{sec:existing_solutions}

TODO

\chapterconclusion

В конце каждой главы это главы я сделаю вывод, что всё хорошо.

%% Макрос для заключения. Совместим со старым стилевиком.
\startconclusionpage

В данном разделе размещается заключение.

\printmainbibliography

\end{document}
