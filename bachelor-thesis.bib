% @online{ doerr-doerr-lambda-lambda-self-adjustment-arxiv,
%     year        = {2015},
%     title       = {Optimal Parameter Choices Through Self-Adjustment: Applying the 1/5-th Rule in
%                    Discrete Settings},
%     author      = {Benjamin Doerr and Carola Doerr},
%     url         = {http://arxiv.org/abs/1504.03212},
%     year        = {2015},
%     langid      = {english}
% }

% @inproceedings{ example-english,
%     year        = {2015},
%     booktitle   = {Proceedings of IEEE Congress on Evolutionary Computation},
%     author      = {Maxim Buzdalov and Anatoly Shalyto},
%     title       = {Hard Test Generation for Augmenting Path Maximum Flow
%                    Algorithms using Genetic Algorithms: Revisited},
%     pages       = {2121-2128},
%     langid      = {english}
% }

% @article{ example-russian,
%     author      = {Максим Викторович Буздалов},
%     title       = {Генерация тестов для олимпиадных задач по программированию
%                    с использованием генетических алгоритмов},
%     journal     = {Научно-технический вестник {СПбГУ} {ИТМО}},
%     number      = {2(72)},
%     year        = {2011},
%     pages       = {72-77},
%     langid      = {russian}
% }

% @article{ unrestricted-jump-evco,
%     author      = {Maxim Buzdalov and Benjamin Doerr and Mikhail Kever},
%     title       = {The Unrestricted Black-Box Complexity of Jump Functions},
%     journal     = {Evolutionary Computation},
%     year        = {2016},
%     note        = {Accepted for publication},
%     langid      = {english}
% }

% @book{ bellman,
%     author      = {R. E. Bellman},
%     title       = {Dynamic Programming},
%     address     = {Princeton, NJ},
%     publisher   = {Princeton University Press},
%     numpages    = {342},
%     pagetotal   = {342},
%     year        = {1957},
%     langid      = {english}
% }


@inproceedings{danielsson_total_2010,
	location = {Baltimore Maryland {USA}},
	title = {Total parser combinators},
	isbn = {978-1-60558-794-3},
	url = {https://dl.acm.org/doi/10.1145/1863543.1863585},
	doi = {10.1145/1863543.1863585},
	eventtitle = {{ICFP} '10: {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {285--296},
	booktitle = {Proceedings of the 15th {ACM} {SIGPLAN} international conference on Functional programming},
	publisher = {{ACM}},
	author = {Danielsson, Nils Anders},
	urldate = {2024-03-27},
	date = {2010-09-27},
	langid = {english},
}

@article{johnson_memoization_nodate,
	title = {Memoization of Top-down Parsing},
	author = {Johnson, Mark},
	langid = {english},
	file = {Johnson - Memoization of Top-down Parsing.pdf:/home/enotvtapke/Zotero/storage/XRYARSUU/Johnson - Memoization of Top-down Parsing.pdf:application/pdf},
}

@article{mcbride_applicative_2008,
	title = {Applicative programming with effects},
	volume = {18},
	issn = {0956-7968, 1469-7653},
	url = {http://www.journals.cambridge.org/abstract_S0956796807006326},
	doi = {10.1017/S0956796807006326},
	abstract = {In this article, we introduce Applicative functors – an abstract characterisation of an applicative style of eﬀectful programming, weaker than Monads and hence more widespread. Indeed, it is the ubiquity of this programming pattern that drew us to the abstraction. We retrace our steps in this article, introducing the applicative pattern by diverse examples, then abstracting it to deﬁne the Applicative type class and introducing a bracket notation that interprets the normal application syntax in the idiom of an Applicative functor. Furthermore, we develop the properties of applicative functors and the generic operations they support. We close by identifying the categorical structure of applicative functors and examining their relationship both with Monads and with Arrows.},
	number = {1},
	journaltitle = {Journal of Functional Programming},
	shortjournal = {J. Funct. Prog.},
	author = {Mcbride, Conor and Paterson, Ross},
	urldate = {2024-03-27},
	date = {2008-01},
	langid = {english},
	file = {Mcbride and Paterson - 2008 - Applicative programming with effects.pdf:/home/enotvtapke/Zotero/storage/H4E3PCD6/Mcbride and Paterson - 2008 - Applicative programming with effects.pdf:application/pdf},
}

@article{frost_new_2006,
	title = {A new top-down parsing algorithm to accommodate ambiguity and left recursion in polynomial time},
	volume = {41},
	issn = {0362-1340, 1558-1160},
	url = {https://dl.acm.org/doi/10.1145/1149982.1149988},
	doi = {10.1145/1149982.1149988},
	abstract = {Top-down backtracking language processors are highly modular, can handle ambiguity, and are easy to implement with clear and maintainable code. However, a widely-held, and incorrect, view is that top-down processors are inherently exponential for ambiguous grammars and cannot accommodate left-recursive productions. It has been known for many years that exponential complexity can be avoided by memoization, and that left-recursive productions can be accommodated through a variety of techniques. However, until now, memoization and techniques for handling left recursion have either been presented independently, or else attempts at their integration have compromised modularity and clarity of the code.},
	pages = {46--54},
	number = {5},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Frost, Richard A. and Hafiz, Rahmatullah},
	urldate = {2024-03-27},
	date = {2006-05},
	langid = {english},
	file = {Frost and Hafiz - 2006 - A new top-down parsing algorithm to accommodate am.pdf:/home/enotvtapke/Zotero/storage/L7IZB3IF/Frost and Hafiz - 2006 - A new top-down parsing algorithm to accommodate am.pdf:application/pdf},
}

@article{hutton_monadic_nodate,
	title = {Monadic Parser Combinators},
	abstract = {In functional programming, a popular approach to building recursive descent parsers is to model parsers as functions, and to deﬁne higher-order functions (or combinators) that implement grammar constructions such as sequencing, choice, and repetition. Such parsers form an instance of a monad , an algebraic structure from mathematics that has proved useful for addressing a number of computational problems. The purpose of this article is to provide a step-by-step tutorial on the monadic approach to building functional parsers, and to explain some of the beneﬁts that result from exploiting monads. No prior knowledge of parser combinators or of monads is assumed. Indeed, this article can also be viewed as a ﬁrst introduction to the use of monads in programming.},
	author = {Hutton, Graham and Meijer, Erik},
	langid = {english},
	file = {Hutton and Meijer - Monadic Parser Combinators.pdf:/home/enotvtapke/Zotero/storage/ZEZKJLT2/Hutton and Meijer - Monadic Parser Combinators.pdf:application/pdf},
}

@incollection{hudak_parser_2008,
	location = {Berlin, Heidelberg},
	title = {Parser Combinators for Ambiguous Left-Recursive Grammars},
	volume = {4902},
	isbn = {978-3-540-77441-9 978-3-540-77442-6},
	url = {http://link.springer.com/10.1007/978-3-540-77442-6_12},
	abstract = {Parser combinators are higher-order functions used to build parsers as executable speciﬁcations of grammars. Some existing implementations are only able to handle limited ambiguity, some have exponential time and/or space complexity for ambiguous input, most cannot accommodate left-recursive grammars. This paper describes combinators, implemented in Haskell, which overcome all of these limitations.},
	pages = {167--181},
	booktitle = {Practical Aspects of Declarative Languages},
	publisher = {Springer Berlin Heidelberg},
	author = {Frost, Richard A. and Hafiz, Rahmatullah and Callaghan, Paul},
	editor = {Hudak, Paul and Warren, David S.},
	urldate = {2024-03-27},
	date = {2008},
	langid = {english},
	doi = {10.1007/978-3-540-77442-6_12},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Frost et al. - 2008 - Parser Combinators for Ambiguous Left-Recursive Gr.pdf:/home/enotvtapke/Zotero/storage/BC6HSFNX/Frost et al. - 2008 - Parser Combinators for Ambiguous Left-Recursive Gr.pdf:application/pdf},
}

@article{ford_parsing_nodate,
	title = {Parsing Expression Grammars: A Recognition-Based Syntactic Foundation},
	abstract = {For decades we have been using Chomsky’s generative system of grammars, particularly context-free grammars ({CFGs}) and regular expressions ({REs}), to express the syntax of programming languages and protocols. The power of generative grammars to express ambiguity is crucial to their original purpose of modelling natural languages, but this very power makes it unnecessarily difﬁcult both to express and to parse machine-oriented languages using {CFGs}. Parsing Expression Grammars ({PEGs}) provide an alternative, recognition-based formal foundation for describing machineoriented syntax, which solves the ambiguity problem by not introducing ambiguity in the ﬁrst place. Where {CFGs} express nondeterministic choice between alternatives, {PEGs} instead use prioritized choice. {PEGs} address frequently felt expressiveness limitations of {CFGs} and {REs}, simplifying syntax deﬁnitions and making it unnecessary to separate their lexical and hierarchical components. A linear-time parser can be built for any {PEG}, avoiding both the complexity and ﬁckleness of {LR} parsers and the inefﬁciency of generalized {CFG} parsing. While {PEGs} provide a rich set of operators for constructing grammars, they are reducible to two minimal recognition schemas developed around 1970, {TS}/{TDPL} and {gTS}/{GTDPL}, which are here proven equivalent in effective recognition power.},
	author = {Ford, Bryan},
	langid = {english},
	file = {Ford - Parsing Expression Grammars A Recognition-Based S.pdf:/home/enotvtapke/Zotero/storage/YSEWEWT7/Ford - Parsing Expression Grammars A Recognition-Based S.pdf:application/pdf},
}

@inproceedings{izmaylova_practical_2016,
	location = {St. Petersburg {FL} {USA}},
	title = {Practical, general parser combinators},
	isbn = {978-1-4503-4097-7},
	url = {https://dl.acm.org/doi/10.1145/2847538.2847539},
	doi = {10.1145/2847538.2847539},
	abstract = {Parser combinators are a popular approach to parsing where contextfree grammars are represented as executable code. However, conventional parser combinators do not support left recursion, and can have worst-case exponential runtime. These limitations hinder the expressivity and performance predictability of parser combinators when constructing parsers for programming languages.},
	eventtitle = {{POPL} '16: The 43rd Annual {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	pages = {1--12},
	booktitle = {Proceedings of the 2016 {ACM} {SIGPLAN} Workshop on Partial Evaluation and Program Manipulation},
	publisher = {{ACM}},
	author = {Izmaylova, Anastasia and Afroozeh, Ali and Storm, Tijs Van Der},
	urldate = {2024-03-27},
	date = {2016-01-11},
	langid = {english},
	file = {Izmaylova et al. - 2016 - Practical, general parser combinators.pdf:/home/enotvtapke/Zotero/storage/WSGSPLN4/Izmaylova et al. - 2016 - Practical, general parser combinators.pdf:application/pdf;Thesis.pdf:/home/enotvtapke/Zotero/storage/AL5Q6AET/Thesis.pdf:application/pdf},
}

@article{willis_staged_2020,
	title = {Staged selective parser combinators},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3409002},
	doi = {10.1145/3409002},
	abstract = {{JAMIE} {WILLIS}, Imperial College London, United Kingdom {NICOLAS} {WU}, Imperial College London, United Kingdom {MATTHEW} {PICKERING}, University of Bristol, United Kingdom Parser combinators are a middle ground between the fine control of hand-rolled parsers and the high-level almost grammar-like appearance of parsers created via parser generators. They also promote a cleaner, compositional design for parsers. Historically, however, they cannot match the performance of their counterparts. This paper describes how to compile parser combinators into parsers of hand-written quality. This is done by leveraging the static information present in the grammar by representing it as a tree. However, in order to exploit this information, it will be necessary to drop support for monadic computation since this generates dynamic structure. Selective functors can help recover lost functionality in the absence of monads, and the parser tree can be partially evaluated with staging. This is implemented in a library called Parsley. {CCS} Concepts: · Software and its engineering → Functional languages; Parsers.},
	pages = {1--30},
	issue = {{ICFP}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Willis, Jamie and Wu, Nicolas and Pickering, Matthew},
	urldate = {2024-03-27},
	date = {2020-08-02},
	langid = {english},
	file = {Willis et al. - 2020 - Staged selective parser combinators.pdf:/home/enotvtapke/Zotero/storage/MUVZQVRT/Willis et al. - 2020 - Staged selective parser combinators.pdf:application/pdf},
}

@inproceedings{warth_packrat_2008,
	location = {San Francisco California {USA}},
	title = {Packrat parsers can support left recursion},
	isbn = {978-1-59593-977-7},
	url = {https://dl.acm.org/doi/10.1145/1328408.1328424},
	doi = {10.1145/1328408.1328424},
	abstract = {Packrat parsing offers several advantages over other parsing techniques, such as the guarantee of linear parse times while supporting backtracking and unlimited look-ahead. Unfortunately, the limited support for left recursion in packrat parser implementations makes them difﬁcult to use for a large class of grammars (Java’s, for example). This paper presents a modiﬁcation to the memoization mechanism used by packrat parser implementations that makes it possible for them to support (even indirectly or mutually) left-recursive rules. While it is possible for a packrat parser with our modiﬁcation to yield super-linear parse times for some left-recursive grammars, our experiments show that this is not the case for typical uses of left recursion.},
	eventtitle = {{PEPM}08: Partial Evaluation and Program Manipulation},
	pages = {103--110},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} symposium on Partial evaluation and semantics-based program manipulation},
	publisher = {{ACM}},
	author = {Warth, Alessandro and Douglass, James R. and Millstein, Todd},
	urldate = {2024-03-27},
	date = {2008-01-07},
	langid = {english},
	file = {Warth et al. - 2008 - Packrat parsers can support left recursion.pdf:/home/enotvtapke/Zotero/storage/P9Z4GGY6/Warth et al. - 2008 - Packrat parsers can support left recursion.pdf:application/pdf},
}

@book{nederhof_linguistic_1994,
	title = {Linguistic parsing and program transformations},
	isbn = {978-90-90-07607-2},
	pagetotal = {206},
	author = {Nederhof, Mark J.},
	date = {1994},
	langid = {english},
	file = {Nederhof - 1994 - Linguistic parsing and program transformations.pdf:/home/enotvtapke/Zotero/storage/G3794L8W/Nederhof - 1994 - Linguistic parsing and program transformations.pdf:application/pdf},
}

@article{ford_packrat_nodate,
	title = {Packrat Parsing: a Practical Linear-Time Algorithm with Backtracking},
	abstract = {Packrat parsing is a novel and practical method for implementing linear-time parsers for grammars deﬁned in Top-Down Parsing Language ({TDPL}). While {TDPL} was originally created as a formal model for top-down parsers with backtracking capability, this thesis extends {TDPL} into a powerful general-purpose notation for describing language syntax, providing a compelling alternative to traditional context-free grammars ({CFGs}). Common syntactic idioms that cannot be represented concisely in a {CFG} are easily expressed in {TDPL}, such as longest-match disambiguation and “syntactic predicates,” making it possible to describe the complete lexical and grammatical syntax of a practical programming language in a single {TDPL} grammar.},
	author = {Ford, Bryan},
	langid = {english},
	file = {Ford - Packrat Parsing a Practical Linear-Time Algorithm.pdf:/home/enotvtapke/Zotero/storage/9W44F5HF/Ford - Packrat Parsing a Practical Linear-Time Algorithm.pdf:application/pdf},
}

@inproceedings{willis_design_2021,
	location = {Virtual Republic of Korea},
	title = {Design patterns for parser combinators (functional pearl)},
	isbn = {978-1-4503-8615-9},
	url = {https://dl.acm.org/doi/10.1145/3471874.3472984},
	doi = {10.1145/3471874.3472984},
	abstract = {Parser combinators are a popular and elegant approach for parsing in functional languages. The design and implementation of such libraries are well discussed, but having a welldesigned library is only one-half of the story. In this paper we explore several reusable approaches to writing parsers in combinator style, focusing on easy to apply patterns to keep parsing code simple, separated, and maintainable.},
	eventtitle = {{ICFP} '21: 26th {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {71--84},
	booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} International Symposium on Haskell},
	publisher = {{ACM}},
	author = {Willis, Jamie and Wu, Nicolas},
	urldate = {2024-03-28},
	date = {2021-08-18},
	langid = {english},
	file = {Willis and Wu - 2021 - Design patterns for parser combinators (functional.pdf:/home/enotvtapke/Zotero/storage/AE2VLPI9/Willis and Wu - 2021 - Design patterns for parser combinators (functional.pdf:application/pdf},
}

@misc{abdallah_memoisation_2017,
	title = {Memoisation: Purely, Left-recursively, and with (Continuation Passing) Style},
	url = {http://arxiv.org/abs/1707.04724},
	shorttitle = {Memoisation},
	abstract = {Memoisation, or tabling, is a well-known technique that yields large improvements in the performance of some recursive computations. Tabled resolution in Prologs such as {XSB} and B-Prolog can transform so called left-recursive predicates from non-terminating computations into ﬁnite and well-behaved ones. In the functional programming literature, memoisation has usually been implemented in a way that does not handle leftrecursion, requiring supplementary mechanisms to prevent non-termination. A notable exception is Johnson’s (1995) continuation passing approach in Scheme. This, however, relies on mutation of a memo table data structure and coding in explicit continuation passing style. We show how Johnson’s approach can be implemented purely functionally in a modern, strongly typed functional language ({OCaml}), presented via a monadic interface that hides the implementation details, yet providing a way to return a compact represention of the memo tables at the end of the computation.},
	number = {{arXiv}:1707.04724},
	publisher = {{arXiv}},
	author = {Abdallah, Samer},
	urldate = {2024-03-28},
	date = {2017-07-15},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {1707.04724 [cs]},
	keywords = {Computer Science - Computation and Language, Computer Science - Logic in Computer Science, Computer Science - Programming Languages},
	file = {Abdallah - 2017 - Memoisation Purely, Left-recursively, and with (C.pdf:/home/enotvtapke/Zotero/storage/5EI9VKUH/Abdallah - 2017 - Memoisation Purely, Left-recursively, and with (C.pdf:application/pdf},
}

@article{abdallah_memoisation_nodate,
	title = {Memoisation: Purely, Left-recursively, and with (Continuation Passing) Style},
	abstract = {Memoisation, or tabling, is a well-known technique that yields large improvements in the performance of some recursive computations. Tabled resolution in Prologs such as {XSB} and B-Prolog can transform so called left-recursive predicates from non-terminating computations into ﬁnite and well-behaved ones. In the functional programming literature, memoisation has usually been implemented in a way that does not handle leftrecursion, requiring supplementary mechanisms to prevent non-termination. A notable exception is Johnson’s (1995) continuation passing approach in Scheme. This, however, relies on mutation of a memo table data structure and coding in explicit continuation passing style. We show how Johnson’s approach can be implemented purely functionally in a modern, strongly typed functional language ({OCaml}), presented via a monadic interface that hides the implementation details, yet providing a way to return a compact represention of the memo tables at the end of the computation.},
	author = {Abdallah, Samer},
	langid = {english},
	file = {Abdallah - Memoisation Purely, Left-recursively, and with (C.pdf:/home/enotvtapke/Zotero/storage/HIHXYR5C/Abdallah - Memoisation Purely, Left-recursively, and with (C.pdf:application/pdf},
}

@article{abdallah_memoisation_2017-1,
	title = {Memoisation: Purely, Left-recursively, and with (Continuation Passing) Style},
	shorttitle = {Memoisation},
	abstract = {Memoisation, or tabling, is a well-known technique that yields large improvements in the performance of some recursive computations. Tabled resolution in Prologs such as {XSB} and B-Prolog can transform so called left-recursive predicates from non-terminating computations into finite and well-behaved ones. In the functional programming literature, memoisation has usually been implemented in a way that does not handle left-recursion, requiring supplementary mechanisms to prevent non-termination. A notable exception is Johnson's (1995) continuation passing approach in Scheme. This, however, relies on mutation of a memo table data structure and coding in explicit continuation passing style. We show how Johnson's approach can be implemented purely functionally in a modern, strongly typed functional language ({OCaml}), presented via a monadic interface that hides the implementation details, yet providing a way to return a compact represention of the memo tables at the end of the computation.},
	author = {Abdallah, Samer},
	date = {2017-07-15},
	file = {Full Text PDF:/home/enotvtapke/Zotero/storage/IF8RRMI2/Abdallah - 2017 - Memoisation Purely, Left-recursively, and with (C.pdf:application/pdf},
}

@incollection{goos_stretching_2000,
	location = {Berlin, Heidelberg},
	title = {Stretching the Storage Manager: Weak Pointers and Stable Names in Haskell},
	volume = {1868},
	isbn = {978-3-540-67864-9 978-3-540-44658-3},
	url = {http://link.springer.com/10.1007/10722298_3},
	shorttitle = {Stretching the Storage Manager},
	abstract = {Every now and then, a user of the Glasgow Haskell Compiler asks for a feature that requires specialised support from the storage manager. Memo functions, pointer equality, external pointers, ﬁnalizers, and weak pointers, are all examples.},
	pages = {37--58},
	booktitle = {Implementation of Functional Languages},
	publisher = {Springer Berlin Heidelberg},
	author = {Peyton Jones, Simon and Marlow, Simon and Elliott, Conal},
	editor = {Koopman, Pieter and Clack, Chris},
	editorb = {Goos, Gerhard and Hartmanis, Juris and Van Leeuwen, Jan},
	editorbtype = {redactor},
	urldate = {2024-04-11},
	date = {2000},
	langid = {english},
	doi = {10.1007/10722298_3},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Peyton Jones et al. - 2000 - Stretching the Storage Manager Weak Pointers and .pdf:/home/enotvtapke/Zotero/storage/V7QCEDNX/Peyton Jones et al. - 2000 - Stretching the Storage Manager Weak Pointers and .pdf:application/pdf},
}

@article{norvig_techniques_1991,
	title = {Techniques for automatic memoization with applications to context-free parsing},
	volume = {17},
	abstract = {It is shown that a process similar to Earley's algorithm can be generated by a simple top-down backtracking parser, when augmented by automatic memoization. The memoized parser has the same complexity as Earley's algorithm, but parses constituents in a different order. Techniques for deriving memo functions are described, with a complete implementation in Common Lisp, and an outline of a macro-based approach for other languages.},
	journaltitle = {Computational Linguistics - {COLI}},
	shortjournal = {Computational Linguistics - {COLI}},
	author = {Norvig, Peter},
	date = {1991-01-01},
	file = {Full Text PDF:/home/enotvtapke/Zotero/storage/74FJLUYD/Norvig - 1991 - Techniques for automatic memoization with applicat.pdf:application/pdf},
}

@online{megaparsec,
	title = {megaparsec},
	url = {//hackage.haskell.org/package/megaparsec},
	abstract = {Monadic parser combinators},
	titleaddon = {Hackage},
	urldate = {2024-04-22},
    langid = {english},
	file = {Snapshot:/home/enotvtapke/Zotero/storage/QMMHKQCI/megaparsec.html:text/html},
}

@online{bison,
	title = {Bison - {GNU} Project - Free Software Foundation},
	url = {https://www.gnu.org/software/bison/},
	urldate = {2024-04-22},
    langid = {english},
	file = {Bison - GNU Project - Free Software Foundation:/home/enotvtapke/Zotero/storage/ENTHYTQQ/bison.html:text/html},
}

@online{antlr,
	title = {{ANTLR}},
	url = {https://www.antlr.org/},
	urldate = {2024-04-22},
    langid = {english},
	file = {ANTLR:/home/enotvtapke/Zotero/storage/BSQ8B7VP/www.antlr.org.html:text/html},
}

@online{noauthor_haskellcontinuation_nodate,
	title = {Haskell/Continuation passing style - Wikibooks, open books for an open world},
	url = {https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style},
	urldate = {2024-04-27},
	langid = {english},
	file = {Snapshot:/home/enotvtapke/Zotero/storage/ZVNRFP9S/Continuation_passing_style.html:text/html},
}

@online{noauthor_systemmemstablename_nodate,
	title = {System.Mem.{StableName}},
	url = {https://hackage.haskell.org/package/base-4.19.1.0/docs/System-Mem-StableName.html},
	urldate = {2024-05-01},
	file = {System.Mem.StableName:/home/enotvtapke/Zotero/storage/I2RXS3GH/System-Mem-StableName.html:text/html},
}
