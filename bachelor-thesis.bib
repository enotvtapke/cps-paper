
@article{mcbride_applicative_2008,
	title = {Applicative programming with effects},
	volume = {18},
	issn = {0956-7968, 1469-7653},
	url = {http://www.journals.cambridge.org/abstract_S0956796807006326},
	doi = {10.1017/S0956796807006326},
	abstract = {In this article, we introduce Applicative functors – an abstract characterisation of an applicative style of eﬀectful programming, weaker than Monads and hence more widespread. Indeed, it is the ubiquity of this programming pattern that drew us to the abstraction. We retrace our steps in this article, introducing the applicative pattern by diverse examples, then abstracting it to deﬁne the Applicative type class and introducing a bracket notation that interprets the normal application syntax in the idiom of an Applicative functor. Furthermore, we develop the properties of applicative functors and the generic operations they support. We close by identifying the categorical structure of applicative functors and examining their relationship both with Monads and with Arrows.},
	number = {1},
	journaltitle = {Journal of Functional Programming},
	shortjournal = {J. Funct. Prog.},
	author = {Mcbride, Conor and Paterson, Ross},
	urldate = {2024-03-27},
	date = {2008-01},
	langid = {english},
	file = {Mcbride and Paterson - 2008 - Applicative programming with effects.pdf:/home/enotvtapke/Zotero/storage/H4E3PCD6/Mcbride and Paterson - 2008 - Applicative programming with effects.pdf:application/pdf},
}

@article{frost_new_2006,
	title = {A new top-down parsing algorithm to accommodate ambiguity and left recursion in polynomial time},
	volume = {41},
	issn = {0362-1340, 1558-1160},
	url = {https://dl.acm.org/doi/10.1145/1149982.1149988},
	doi = {10.1145/1149982.1149988},
	abstract = {Top-down backtracking language processors are highly modular, can handle ambiguity, and are easy to implement with clear and maintainable code. However, a widely-held, and incorrect, view is that top-down processors are inherently exponential for ambiguous grammars and cannot accommodate left-recursive productions. It has been known for many years that exponential complexity can be avoided by memoization, and that left-recursive productions can be accommodated through a variety of techniques. However, until now, memoization and techniques for handling left recursion have either been presented independently, or else attempts at their integration have compromised modularity and clarity of the code.},
	pages = {46--54},
	number = {5},
	journaltitle = {{ACM} {SIGPLAN} Notices},
	shortjournal = {{SIGPLAN} Not.},
	author = {Frost, Richard A. and Hafiz, Rahmatullah},
	urldate = {2024-03-27},
	date = {2006-05},
	langid = {english},
	file = {Frost and Hafiz - 2006 - A new top-down parsing algorithm to accommodate am.pdf:/home/enotvtapke/Zotero/storage/L7IZB3IF/Frost and Hafiz - 2006 - A new top-down parsing algorithm to accommodate am.pdf:application/pdf},
}

@incollection{hudak_parser_2008,
	location = {Berlin, Heidelberg},
	title = {Parser Combinators for Ambiguous Left-Recursive Grammars},
	volume = {4902},
	isbn = {978-3-540-77441-9 978-3-540-77442-6},
	url = {http://link.springer.com/10.1007/978-3-540-77442-6_12},
	abstract = {Parser combinators are higher-order functions used to build parsers as executable speciﬁcations of grammars. Some existing implementations are only able to handle limited ambiguity, some have exponential time and/or space complexity for ambiguous input, most cannot accommodate left-recursive grammars. This paper describes combinators, implemented in Haskell, which overcome all of these limitations.},
	pages = {167--181},
	booktitle = {Practical Aspects of Declarative Languages},
	publisher = {Springer Berlin Heidelberg},
	author = {Frost, Richard A. and Hafiz, Rahmatullah and Callaghan, Paul},
	editor = {Hudak, Paul and Warren, David S.},
	urldate = {2024-03-27},
	date = {2008},
	langid = {english},
	doi = {10.1007/978-3-540-77442-6_12},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Frost et al. - 2008 - Parser Combinators for Ambiguous Left-Recursive Gr.pdf:/home/enotvtapke/Zotero/storage/BC6HSFNX/Frost et al. - 2008 - Parser Combinators for Ambiguous Left-Recursive Gr.pdf:application/pdf},
}

@inproceedings{izmaylova_practical_2016,
	location = {St. Petersburg {FL} {USA}},
	title = {Practical, general parser combinators},
	isbn = {978-1-4503-4097-7},
	url = {https://dl.acm.org/doi/10.1145/2847538.2847539},
	doi = {10.1145/2847538.2847539},
	abstract = {Parser combinators are a popular approach to parsing where contextfree grammars are represented as executable code. However, conventional parser combinators do not support left recursion, and can have worst-case exponential runtime. These limitations hinder the expressivity and performance predictability of parser combinators when constructing parsers for programming languages.},
	eventtitle = {{POPL} '16: The 43rd Annual {ACM} {SIGPLAN}-{SIGACT} Symposium on Principles of Programming Languages},
	pages = {1--12},
	booktitle = {Proceedings of the 2016 {ACM} {SIGPLAN} Workshop on Partial Evaluation and Program Manipulation},
	publisher = {{ACM}},
	author = {Izmaylova, Anastasia and Afroozeh, Ali and Storm, Tijs Van Der},
	urldate = {2024-03-27},
	date = {2016-01-11},
	langid = {english},
	file = {Izmaylova et al. - 2016 - Practical, general parser combinators.pdf:/home/enotvtapke/Zotero/storage/WSGSPLN4/Izmaylova et al. - 2016 - Practical, general parser combinators.pdf:application/pdf;Thesis.pdf:/home/enotvtapke/Zotero/storage/AL5Q6AET/Thesis.pdf:application/pdf},
}

@article{willis_staged_2020,
	title = {Staged selective parser combinators},
	volume = {4},
	issn = {2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3409002},
	doi = {10.1145/3409002},
	abstract = {{JAMIE} {WILLIS}, Imperial College London, United Kingdom {NICOLAS} {WU}, Imperial College London, United Kingdom {MATTHEW} {PICKERING}, University of Bristol, United Kingdom Parser combinators are a middle ground between the fine control of hand-rolled parsers and the high-level almost grammar-like appearance of parsers created via parser generators. They also promote a cleaner, compositional design for parsers. Historically, however, they cannot match the performance of their counterparts. This paper describes how to compile parser combinators into parsers of hand-written quality. This is done by leveraging the static information present in the grammar by representing it as a tree. However, in order to exploit this information, it will be necessary to drop support for monadic computation since this generates dynamic structure. Selective functors can help recover lost functionality in the absence of monads, and the parser tree can be partially evaluated with staging. This is implemented in a library called Parsley. {CCS} Concepts: · Software and its engineering → Functional languages; Parsers.},
	pages = {1--30},
	issue = {{ICFP}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Willis, Jamie and Wu, Nicolas and Pickering, Matthew},
	urldate = {2024-03-27},
	date = {2020-08-02},
	langid = {english},
	file = {Willis et al. - 2020 - Staged selective parser combinators.pdf:/home/enotvtapke/Zotero/storage/MUVZQVRT/Willis et al. - 2020 - Staged selective parser combinators.pdf:application/pdf},
}

@inproceedings{warth_packrat_2008,
	location = {San Francisco California {USA}},
	title = {Packrat parsers can support left recursion},
	isbn = {978-1-59593-977-7},
	url = {https://dl.acm.org/doi/10.1145/1328408.1328424},
	doi = {10.1145/1328408.1328424},
	abstract = {Packrat parsing offers several advantages over other parsing techniques, such as the guarantee of linear parse times while supporting backtracking and unlimited look-ahead. Unfortunately, the limited support for left recursion in packrat parser implementations makes them difﬁcult to use for a large class of grammars (Java’s, for example). This paper presents a modiﬁcation to the memoization mechanism used by packrat parser implementations that makes it possible for them to support (even indirectly or mutually) left-recursive rules. While it is possible for a packrat parser with our modiﬁcation to yield super-linear parse times for some left-recursive grammars, our experiments show that this is not the case for typical uses of left recursion.},
	eventtitle = {{PEPM}08: Partial Evaluation and Program Manipulation},
	pages = {103--110},
	booktitle = {Proceedings of the 2008 {ACM} {SIGPLAN} symposium on Partial evaluation and semantics-based program manipulation},
	publisher = {{ACM}},
	author = {Warth, Alessandro and Douglass, James R. and Millstein, Todd},
	urldate = {2024-03-27},
	date = {2008-01-07},
	langid = {english},
	file = {Warth et al. - 2008 - Packrat parsers can support left recursion.pdf:/home/enotvtapke/Zotero/storage/P9Z4GGY6/Warth et al. - 2008 - Packrat parsers can support left recursion.pdf:application/pdf},
}

@book{nederhof_linguistic_1994,
	title = {Linguistic parsing and program transformations},
	isbn = {978-90-90-07607-2},
	pagetotal = {206},
	author = {Nederhof, Mark J.},
	date = {1994},
	langid = {english},
	file = {Nederhof - 1994 - Linguistic parsing and program transformations.pdf:/home/enotvtapke/Zotero/storage/G3794L8W/Nederhof - 1994 - Linguistic parsing and program transformations.pdf:application/pdf},
}

@article{ford_packrat_nodate,
	title = {Packrat Parsing: a Practical Linear-Time Algorithm with Backtracking},
	abstract = {Packrat parsing is a novel and practical method for implementing linear-time parsers for grammars deﬁned in Top-Down Parsing Language ({TDPL}). While {TDPL} was originally created as a formal model for top-down parsers with backtracking capability, this thesis extends {TDPL} into a powerful general-purpose notation for describing language syntax, providing a compelling alternative to traditional context-free grammars ({CFGs}). Common syntactic idioms that cannot be represented concisely in a {CFG} are easily expressed in {TDPL}, such as longest-match disambiguation and “syntactic predicates,” making it possible to describe the complete lexical and grammatical syntax of a practical programming language in a single {TDPL} grammar.},
	author = {Ford, Bryan},
	langid = {english},
	file = {Ford - Packrat Parsing a Practical Linear-Time Algorithm.pdf:/home/enotvtapke/Zotero/storage/9W44F5HF/Ford - Packrat Parsing a Practical Linear-Time Algorithm.pdf:application/pdf},
}

@inproceedings{willis_design_2021,
	location = {Virtual Republic of Korea},
	title = {Design patterns for parser combinators (functional pearl)},
	isbn = {978-1-4503-8615-9},
	url = {https://dl.acm.org/doi/10.1145/3471874.3472984},
	doi = {10.1145/3471874.3472984},
	abstract = {Parser combinators are a popular and elegant approach for parsing in functional languages. The design and implementation of such libraries are well discussed, but having a welldesigned library is only one-half of the story. In this paper we explore several reusable approaches to writing parsers in combinator style, focusing on easy to apply patterns to keep parsing code simple, separated, and maintainable.},
	eventtitle = {{ICFP} '21: 26th {ACM} {SIGPLAN} International Conference on Functional Programming},
	pages = {71--84},
	booktitle = {Proceedings of the 14th {ACM} {SIGPLAN} International Symposium on Haskell},
	publisher = {{ACM}},
	author = {Willis, Jamie and Wu, Nicolas},
	urldate = {2024-03-28},
	date = {2021-08-18},
	langid = {english},
	file = {Willis and Wu - 2021 - Design patterns for parser combinators (functional.pdf:/home/enotvtapke/Zotero/storage/AE2VLPI9/Willis and Wu - 2021 - Design patterns for parser combinators (functional.pdf:application/pdf},
}

@article{abdallah_memoisation_2017,
	title = {Memoisation: Purely, Left-recursively, and with (Continuation Passing) Style},
	shorttitle = {Memoisation},
	abstract = {Memoisation, or tabling, is a well-known technique that yields large improvements in the performance of some recursive computations. Tabled resolution in Prologs such as {XSB} and B-Prolog can transform so called left-recursive predicates from non-terminating computations into finite and well-behaved ones. In the functional programming literature, memoisation has usually been implemented in a way that does not handle left-recursion, requiring supplementary mechanisms to prevent non-termination. A notable exception is Johnson's (1995) continuation passing approach in Scheme. This, however, relies on mutation of a memo table data structure and coding in explicit continuation passing style. We show how Johnson's approach can be implemented purely functionally in a modern, strongly typed functional language ({OCaml}), presented via a monadic interface that hides the implementation details, yet providing a way to return a compact represention of the memo tables at the end of the computation.},
	author = {Abdallah, Samer},
	date = {2017-07-15},
	langid = {english},
	file = {Full Text PDF:/home/enotvtapke/Zotero/storage/IF8RRMI2/Abdallah - 2017 - Memoisation Purely, Left-recursively, and with (C.pdf:application/pdf},
}

@incollection{goos_stretching_2000,
	location = {Berlin, Heidelberg},
	title = {Stretching the Storage Manager: Weak Pointers and Stable Names in Haskell},
	volume = {1868},
	isbn = {978-3-540-67864-9 978-3-540-44658-3},
	url = {http://link.springer.com/10.1007/10722298_3},
	shorttitle = {Stretching the Storage Manager},
	abstract = {Every now and then, a user of the Glasgow Haskell Compiler asks for a feature that requires specialised support from the storage manager. Memo functions, pointer equality, external pointers, ﬁnalizers, and weak pointers, are all examples.},
	pages = {37--58},
	booktitle = {Implementation of Functional Languages},
	publisher = {Springer Berlin Heidelberg},
	author = {Peyton Jones, Simon and Marlow, Simon and Elliott, Conal},
	editor = {Koopman, Pieter and Clack, Chris},
	editorb = {Goos, Gerhard and Hartmanis, Juris and Van Leeuwen, Jan},
	editorbtype = {redactor},
	urldate = {2024-04-11},
	date = {2000},
	langid = {english},
	doi = {10.1007/10722298_3},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Peyton Jones et al. - 2000 - Stretching the Storage Manager Weak Pointers and .pdf:/home/enotvtapke/Zotero/storage/V7QCEDNX/Peyton Jones et al. - 2000 - Stretching the Storage Manager Weak Pointers and .pdf:application/pdf},
}

@online{noauthor_megaparsec_nodate,
	title = {megaparsec},
	url = {//hackage.haskell.org/package/megaparsec},
	abstract = {Monadic parser combinators},
	titleaddon = {Hackage},
	urldate = {2024-04-22},
	langid = {english},
	file = {Snapshot:/home/enotvtapke/Zotero/storage/QMMHKQCI/megaparsec.html:text/html},
}

@online{noauthor_bison_nodate,
	title = {Bison - {GNU} Project - Free Software Foundation},
	url = {https://www.gnu.org/software/bison/},
	urldate = {2024-04-22},
	langid = {english},
	file = {Bison - GNU Project - Free Software Foundation:/home/enotvtapke/Zotero/storage/ENTHYTQQ/bison.html:text/html},
}

@online{noauthor_antlr_nodate,
	title = {{ANTLR}},
	url = {https://www.antlr.org/},
	urldate = {2024-04-22},
	langid = {english},
	file = {ANTLR:/home/enotvtapke/Zotero/storage/BSQ8B7VP/www.antlr.org.html:text/html},
}

@article{norvig_technical_nodate,
	title = {Technical Correspondence Techniques for Automatic Memoization with Applications to Context-Free Parsing},
	volume = {17},
	number = {1},
	journaltitle = {Computational Linguistics},
	author = {Norvig, Peter},
	langid = {english},
	file = {Norvig - Technical Correspondence Techniques for Automatic .pdf:/home/enotvtapke/Zotero/storage/GKD2J7UN/Norvig - Technical Correspondence Techniques for Automatic .pdf:application/pdf},
}

@article{scott_sppf-style_2008,
	title = {{SPPF}-Style Parsing From Earley Recognisers},
	volume = {203},
	issn = {1571-0661},
	url = {https://www.sciencedirect.com/science/article/pii/S1571066108001497},
	doi = {10.1016/j.entcs.2008.03.044},
	series = {Proceedings of the Seventh Workshop on Language Descriptions, Tools, and Applications ({LDTA} 2007)},
	abstract = {In its recogniser form, Earley's algorithm for testing whether a string can be derived from a grammar is worst case cubic on general context free grammars ({CFG}). Earley gave an outline of a method for turning his recognisers into parsers, but it turns out that this method is incorrect. Tomita's {GLR} parser returns a shared packed parse forest ({SPPF}) representation of all derivations of a given string from a given {CFG} but is worst case unbounded polynomial order. We have given a modified worst-case cubic version, the {BRNGLR} algorithm, that, for any string and any {CFG}, returns a binarised {SPPF} representation of all possible derivations of a given string. In this paper we apply similar techniques to develop two versions of an Earley parsing algorithm that, in worst-case cubic time, return an {SPPF} representation of all derivations of a given string from a given {CFG}.},
	pages = {53--67},
	number = {2},
	journaltitle = {Electronic Notes in Theoretical Computer Science},
	shortjournal = {Electronic Notes in Theoretical Computer Science},
	author = {Scott, Elizabeth},
	urldate = {2024-04-26},
	date = {2008-04-01},
	keywords = {context free languages, cubic generalised parsing, Earley parsing},
	langid = {english},
	file = {ScienceDirect Snapshot:/home/enotvtapke/Zotero/storage/8NTMUYIQ/S1571066108001497.html:text/html},
}

@online{noauthor_haskellcontinuation_nodate,
	title = {Haskell/Continuation passing style - Wikibooks, open books for an open world},
	url = {https://en.wikibooks.org/wiki/Haskell/Continuation_passing_style},
	urldate = {2024-04-27},
	langid = {english},
	file = {Snapshot:/home/enotvtapke/Zotero/storage/ZVNRFP9S/Continuation_passing_style.html:text/html},
}

@online{noauthor_systemmemstablename_nodate,
	title = {System.Mem.{StableName}},
	url = {https://hackage.haskell.org/package/base-4.19.1.0/docs/System-Mem-StableName.html},
	urldate = {2024-05-01},
	langid = {english},
	file = {System.Mem.StableName:/home/enotvtapke/Zotero/storage/I2RXS3GH/System-Mem-StableName.html:text/html},
}

@online{noauthor_datadynamic_nodate,
	title = {Data.Dynamic},
	url = {https://hackage.haskell.org/package/base-4.19.1.0/docs/Data-Dynamic.html},
	urldate = {2024-05-05},
	langid = {english},
	file = {Data.Dynamic:/home/enotvtapke/Zotero/storage/9SVRC79R/Data-Dynamic.html:text/html},
}

@article{earley_efficient_1970,
	title = {An efficient context-free parsing algorithm},
	volume = {13},
	issn = {0001-0782},
	url = {https://dl.acm.org/doi/10.1145/362007.362035},
	doi = {10.1145/362007.362035},
	abstract = {A parsing algorithm which seems to be the most efficient general context-free algorithm known is described. It is similar to both Knuth's {LR}(k) algorithm and the familiar top-down algorithm. It has a time bound proportional to n3 (where n is the length of the string being parsed) in general; it has an n2 bound for unambiguous grammars; and it runs in linear time on a large class of grammars, which seems to include most practical context-free programming language grammars. In an empirical comparison it appears to be superior to the top-down and bottom-up algorithms studied by Griffiths and Petrick.},
	pages = {94--102},
	number = {2},
	journaltitle = {Communications of the {ACM}},
	shortjournal = {Commun. {ACM}},
	author = {Earley, Jay},
	urldate = {2024-05-08},
	date = {1970-02-01},
	langid = {english},
	keywords = {compilers, computational complexity, context-free grammar, parsing, syntax analysis},
	file = {Full Text PDF:/home/enotvtapke/Zotero/storage/7BTEQRV8/Earley - 1970 - An efficient context-free parsing algorithm.pdf:application/pdf},
}

@incollection{goos_fast_1999,
	location = {Berlin, Heidelberg},
	title = {Fast, Error Correcting Parser Combinators: A Short Tutorial},
	volume = {1725},
	isbn = {978-3-540-66694-3 978-3-540-47849-2},
	url = {http://link.springer.com/10.1007/3-540-47849-3_7},
	shorttitle = {Fast, Error Correcting Parser Combinators},
	pages = {112--131},
	booktitle = {{SOFSEM}’99: Theory and Practice of Informatics},
	publisher = {Springer Berlin Heidelberg},
	author = {Swierstra, S. Doaitse and Azero Alcocer, Pablo R.},
	editor = {Pavelka, Jan and Tel, Gerard and Bartošek, Miroslav},
	editorb = {Goos, Gerhard and Hartmanis, Juris and Van Leeuwen, Jan},
	editorbtype = {redactor},
	urldate = {2024-05-10},
	date = {1999},
	langid = {english},
	doi = {10.1007/3-540-47849-3_7},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Swierstra and Azero Alcocer - 1999 - Fast, Error Correcting Parser Combinators A Short.pdf:/home/enotvtapke/Zotero/storage/MLZUGK9V/Swierstra and Azero Alcocer - 1999 - Fast, Error Correcting Parser Combinators A Short.pdf:application/pdf},
}

@article{leijen_parsec_2001,
	title = {Parsec: Direct Style Monadic Parser Combinators For The Real World},
	shorttitle = {Parsec},
	abstract = {Despite the long list of publications on parser combinators, there does not yet exist a monadic parser combinator library that is applicable in real world situations. In particular naive implementations of parser combinators are likely to su\#er from space leaks and are often unable to report precise error messages in case of parse errors. The Parsec parser combinator library described in this paper, utilizes a novel implementation technique for space and time e\#cient parser combinators that in case of a parse error, report both the position of the error as well as all grammar productions that would have been legal at that point in the input.},
	author = {Leijen, Daan and Meijer, Erik},
	date = {2001-12-26},
	file = {Full Text PDF:/home/enotvtapke/Zotero/storage/WU6Y5VE6/Leijen and Meijer - 2001 - Parsec Direct Style Monadic Parser Combinators Fo.pdf:application/pdf},
}

@misc{johnson_memoization_1995,
	title = {Memoization of Top Down Parsing},
	url = {http://arxiv.org/abs/cmp-lg/9504016},
	doi = {10.48550/arXiv.cmp-lg/9504016},
	abstract = {This paper discusses the relationship between memoized top-down recognizers and chart parsers. It presents a version of memoization suitable for continuation-passing style programs. When applied to a simple formalization of a top-down recognizer it yields a terminating parser.},
	number = {{arXiv}:cmp-lg/9504016},
	publisher = {{arXiv}},
	author = {Johnson, Mark},
	urldate = {2024-05-11},
	date = {1995-04-25},
	langid = {english},
	eprinttype = {arxiv},
	eprint = {cmp-lg/9504016},
	keywords = {Computer Science - Computation and Language},
	file = {arXiv Fulltext PDF:/home/enotvtapke/Zotero/storage/WMWFLJWM/Johnson - 1995 - Memoization of Top Down Parsing.pdf:application/pdf;arXiv.org Snapshot:/home/enotvtapke/Zotero/storage/V5JVUBCE/9504016.html:text/html},
}

@inproceedings{nederhof_new_1993,
	location = {Berlin, Heidelberg},
	title = {A new top-down parsing algorithm for left-recursive {DCGs}},
	isbn = {978-3-540-47945-1},
	doi = {10.1007/3-540-57186-8_74},
	abstract = {In this paper we introduce a new parsing algorithm, called cancellation parsing. Deterministic cancellation parsing with lookahead k can handle the C(k) grammars, which include the {LL}(k) grammars and are contained in the {LC}(k) grammars.},
	pages = {108--122},
	booktitle = {Progamming Language Implementation and Logic Programming},
	publisher = {Springer},
	author = {Nederhof, Mark-Jan},
	editor = {Bruynooghe, Maurice and Penjam, Jaan},
	date = {1993},
	langid = {english},
}

@article{norvig_techniques_1991,
	title = {Techniques for automatic memoization with applications to context-free parsing},
	volume = {17},
	issn = {0891-2017},
	abstract = {It is shown that a process similar to Earley's algorithm can be generated by a simple top-down backtracking parser, when augmented by automatic memoization. The memoized parser has the same complexity as Earley's algorithm, but parses constituents in a different order. Techniques for deriving memo functions are described, with a complete implementation in Common Lisp, and an outline of a macro-based approach for other languages.},
	pages = {91--98},
	number = {1},
	journaltitle = {Computational Linguistics},
	shortjournal = {Comput. Linguist.},
	author = {Norvig, Peter},
	date = {1991-03-01},
	langid = {english},
	file = {Full Text PDF:/home/enotvtapke/Zotero/storage/MK7TC3MU/Norvig - 1991 - Techniques for automatic memoization with applicat.pdf:application/pdf},
}

@inproceedings{ford_parsing_2004,
	location = {New York, {NY}, {USA}},
	title = {Parsing expression grammars: a recognition-based syntactic foundation},
	isbn = {978-1-58113-729-3},
	url = {https://doi.org/10.1145/964001.964011},
	doi = {10.1145/964001.964011},
	series = {{POPL} '04},
	shorttitle = {Parsing expression grammars},
	abstract = {For decades we have been using Chomsky's generative system of grammars, particularly context-free grammars ({CFGs}) and regular expressions ({REs}), to express the syntax of programming languages and protocols. The power of generative grammars to express ambiguity is crucial to their original purpose of modelling natural languages, but this very power makes it unnecessarily difficult both to express and to parse machine-oriented languages using {CFGs}. Parsing Expression Grammars ({PEGs}) provide an alternative, recognition-based formal foundation for describing machine-oriented syntax, which solves the ambiguity problem by not introducing ambiguity in the first place. Where {CFGs} express nondeterministic choice between alternatives, {PEGs} instead use prioritized choice. {PEGs} address frequently felt expressiveness limitations of {CFGs} and {REs}, simplifying syntax definitions and making it unnecessary to separate their lexical and hierarchical components. A linear-time parser can be built for any {PEG}, avoiding both the complexity and fickleness of {LR} parsers and the inefficiency of generalized {CFG} parsing. While {PEGs} provide a rich set of operators for constructing grammars, they are reducible to two minimal recognition schemas developed around 1970, {TS}/{TDPL} and {gTS}/{GTDPL}, which are here proven equivalent in effective recognition power.},
	pages = {111--122},
	booktitle = {Proceedings of the 31st {ACM} {SIGPLAN}-{SIGACT} symposium on Principles of programming languages},
	publisher = {Association for Computing Machinery},
	author = {Ford, Bryan},
	urldate = {2024-05-11},
	date = {2004-01-01},
	langid = {english},
	keywords = {{BNF}, context-free grammars, {GTDPL}, lexical analysis, packrat parsing, parsing expression grammars, regular expressions, scannerless parsing, syntactic predicates, {TDPL}, unified grammars},
	file = {Ford - Parsing Expression Grammars A Recognition-Based S.pdf:/home/enotvtapke/Zotero/storage/YSEWEWT7/Ford - Parsing Expression Grammars A Recognition-Based S.pdf:application/pdf},
}

@article{hutton_monadic_1999,
	title = {Monadic Parser Combinators},
	abstract = {In functional programming, a popular approach to building recursive descent parsers is to model parsers as functions, and to define higher-order functions (or combinators) that implement grammar constructions such as sequencing, choice, and repetition. Such parsers form an instance of a monad , an algebraic structure from mathematics that has proved useful for addressing a number of computational problems. The purpose of this article is to provide a step-by-step tutorial on the monadic approach to building functional parsers, and to explain some of the benefits that result from exploiting monads. No prior knowledge of parser combinators or of monads is assumed. Indeed, this article can also be viewed as a first introduction to the use of monads in programming.},
	author = {Hutton, Graham and Meijer, Erik},
	date = {1999-09-15},
	langid = {english},
	file = {Full Text PDF:/home/enotvtapke/Zotero/storage/77EIJVFZ/Hutton and Meijer - 1999 - Monadic Parser Combinators.pdf:application/pdf},
}
